{
  "unit_id": "SE401",
  "unit_name": "Software Engineering Principles and Practice",
  "description": "This course covers fundamental concepts, methods, and practices for professional software development, including process models, requirements engineering, architectural design, testing, project management, quality management, and software reuse techniques.",
  "level": "Undergraduate",
  "credits": "N/A",
  "learning_outcomes_overall": [
    "Understand the nature and importance of software engineering as a discipline.",
    "Identify and apply various software process models and activities, including coping with change.",
    "Define, elicit, specify, and validate functional and non-functional requirements.",
    "Apply architectural design principles and patterns to structure software systems.",
    "Understand and utilize Component-Based Software Engineering (CBSE) and service-oriented architectures (SOA).",
    "Perform software testing across development, release, and user stages, including test-driven development (TDD).",
    "Understand software project management, including planning, scheduling, risk management, and people motivation.",
    "Apply quality management techniques, standards (like ISO 9001), and software metrics.",
    "Understand and apply Configuration Management (CM) activities such as version control, system building, and release management."
  ],
  "chapters": [
    {
      "chapter_id": "ch1",
      "title": "Introduction to Software Engineering",
      "order": 1,
      "week_label": "Week 1",
      "learning_outcomes": [
        "Define software engineering and explain its importance.",
        "Differentiate between generic and customized software products and their specification processes.",
        "Identify the essential attributes of good software (Maintainability, Dependability, Efficiency, Acceptability).",
        "List and briefly describe the fundamental software process activities (Specification, Development, Validation, Evolution).",
        "Discuss general issues that affect modern software systems (Heterogeneity, Business and social change, Security and trust, Scale).",
        "Describe the diversity of software systems (e.g., Stand-alone, Interactive transaction-based, Embedded control systems, etc.).",
        "Understand the ethical responsibilities of professional software engineers, referencing the ACM/IEEE Code of Ethics."
      ],
      "key_concepts": [
        "Software Engineering Definition: concerned with theories, methods and tools for professional software development.",
        "Software Costs: often dominate computer system costs; maintenance costs may exceed development costs.",
        "Software Project Failure Reasons: increasing system complexity, failure to use software engineering methods.",
        "Generic Software Products: stand-alone systems sold to any customer; specification owned by developer (Page 9, 10).",
        "Customized Software Products: commissioned by a specific customer to meet their needs; specification owned by customer (Page 9, 10).",
        "Essential Attributes of Good Software: Maintainability (allows evolution), Dependability/Security (reliability, safety, security), Efficiency (responsiveness, memory utilization), Acceptability (understandable, usable, compatible) (Page 11).",
        "Software Process Activities: Specification, Development, Validation, Evolution (Page 14).",
        "General Issues Affecting Software: Heterogeneity (distributed systems across diverse devices), Business and social change (rapid change demands quick software adaptation), Security and trust, Scale (embedded systems to Internet-scale cloud systems) (Page 15, 16).",
        "Software Engineering Diversity: No universal set of techniques is applicable to all types of software systems (Page 17).",
        "Application Types: Stand-alone applications, Interactive transaction-based applications (e-commerce), Embedded control systems, Batch processing systems, Entertainment systems, Systems for modeling and simulation, Data collection systems, Systems of systems (Page 18-20).",
        "Software Engineering Fundamentals: Managed development process, Dependability/performance, Requirements management, Software reuse (Page 21).",
        "Internet Software Engineering: Web as a platform, Web services (Chapter 19 reference), Cloud computing (pay according to use) (Page 22).",
        "Web-based SE Concepts: Fundamental principles apply, Software reuse (dominant approach), Incremental and agile development (impractical to specify all requirements in advance), Service-oriented systems, Rich interfaces (AJAX, HTML5) (Page 23-25).",
        "Software Engineering Ethics: Involves wider responsibilities than technical skills; requires honest and ethically responsible behavior (Page 27).",
        "Issues of Professional Responsibility: Confidentiality (respect client/employer confidentiality), Competence (do not misrepresent skills; do not accept work outwith competence), Intellectual property rights, Computer misuse (Page 28, 29).",
        "ACM/IEEE Code of Ethics: Code produced by professional societies containing eight Principles (Public, Client/Employer, Product, Judgment, Management, Profession, Colleagues, Self) (Page 30, 33).",
        "ACM/IEEE Code Rationale: Software engineers commit to making SE a beneficial and respected profession; roles offer opportunities to do good or cause harm (Page 31, 32).",
        "Ethical Dilemmas: Disagreement with management policy, releasing safety-critical system without testing, military/nuclear systems development (Page 35).",
        "Case Studies Introduction: Personal insulin pump, Mentcare patient management system, Wilderness weather station, iLearn digital learning environment (Page 36)."
      ],
      "prerequisites": [],
      "content_reference": {
        "source_type": "slides",
        "file_name": "Ch1 Introduction.pdf",
        "pages": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          37
        ]
      }
    },
    {
      "chapter_id": "ch2",
      "title": "Software Processes",
      "order": 2,
      "week_label": "Week 2",
      "learning_outcomes": [
        "Define the software process and software process model.",
        "Compare and contrast plan-driven and agile processes.",
        "Describe the three fundamental generic process models: waterfall, incremental development, and integration/configuration.",
        "Identify and explain the four fundamental software process activities: specification, development, validation, and evolution.",
        "Explain the methods used for coping with change in software development, including prototyping and incremental delivery.",
        "Explain the process improvement cycle and the two main approaches: process maturity and agile approach.",
        "Describe the SEI capability maturity model levels."
      ],
      "key_concepts": [
        "Software Process: A structured set of activities required to develop a software system (Specification, Design/Implementation, Validation, Evolution) (Page 3).",
        "Software Process Model: An abstract representation of a process from a particular perspective (Page 3).",
        "Process Descriptions: Include activities, products (outcomes), roles (responsibilities), and pre-/post-conditions (Page 4).",
        "Plan-driven Processes: Activities planned in advance; progress measured against plan (Page 5).",
        "Agile Processes: Planning is incremental; easier to change process (Page 5).",
        "Generic Process Models: The waterfall model, Incremental development, Integration and configuration (Page 7).",
        "Waterfall Model Phases: Requirements analysis and definition, System and software design, Implementation and unit testing, Integration and system testing, Operation and maintenance (Page 8, 9).",
        "Waterfall Model Problems: Inflexible partitioning; difficult to accommodate change; suitable when requirements are well-understood (Page 10).",
        "Incremental Development Benefits: Reduced cost of accommodating change, easier customer feedback, more rapid delivery (Page 12).",
        "Incremental Development Problems: Process not visible, system structure tends to degrade (requires refactoring) (Page 13).",
        "Integration and Configuration (Reuse-oriented SE): Based on software reuse (COTS systems); reused elements are configured to user requirements; standard approach for business systems (Page 14).",
        "Types of Reusable Software: Stand-alone application systems (COTS), Collections of objects (.NET or J2EE components), Web services (Page 15).",
        "Reuse-oriented Process Stages: Requirements specification, Software discovery and evaluation, Requirements refinement, Application system configuration, Component adaptation and integration (Page 17).",
        "Reuse Advantages/Disadvantages: Reduced costs/risks, Faster delivery; BUT requirement compromises are inevitable, Loss of control over evolution (Page 18).",
        "Process Activities: Specification, development, validation, evolution (inter-leaved sequence of technical, collaborative, and managerial activities) (Page 20).",
        "Requirements Engineering Process: Elicitation and analysis, Specification, Validation (Page 21, 22).",
        "Software Design and Implementation: Converting specification to executable system; includes Software Design and Implementation (programming/configuring) (Page 23).",
        "Design Activities: Architectural design, Database design, Interface design, Component selection and design (Page 25).",
        "Software Validation (V&V): Shows system conforms to specification and customer needs; involves checking, review, and system testing; Testing is most common V&V activity (Page 27).",
        "Stages of Testing: Component testing, System testing, Acceptance testing (Page 28, 29).",
        "Software Evolution: Change is inevitable due to business changes, new technologies, or platform changes; demarcation between development and maintenance is irrelevant (Page 31, 34).",
        "System Evolution Process: Define system requirements -> Assess existing systems -> Propose system changes -> Modify systems -> New system (Page 32).",
        "Reducing Rework Costs: Change anticipation (prototyping), Change tolerance (incremental development) (Page 35).",
        "Coping with Change: System prototyping (change anticipation), Incremental delivery (change avoidance and tolerance) (Page 36).",
        "Software Prototyping Uses: Requirements elicitation/validation, UI design, back-to-back tests (Page 37).",
        "Prototype Benefits: Improved usability, Closer match to user needs, Improved design quality/maintainability, Reduced development effort (Page 38).",
        "Prototype Development Process: Establish objectives, Define functionality, Develop prototype, Evaluate prototype (Page 39).",
        "Throw-away Prototypes: Must be discarded as unfit for production (non-functional issues, undocumented, degraded structure, quality standards unmet) (Page 41).",
        "Incremental Delivery: Development broken into increments, prioritized requirements included in early increments (Page 42).",
        "Incremental Delivery Advantages: Customer value available earlier, Early increments act as prototype, Lower risk of project failure, Highest priority services tested most (Page 45).",
        "Incremental Delivery Problems: Difficulty identifying common facilities needed by all increments, Conflict with traditional procurement models requiring full specification upfront (Page 46).",
        "Process Improvement: Enhancing quality, reducing costs, accelerating development (Page 48).",
        "Process Improvement Approaches: Process maturity approach (improving project management and engineering practice), Agile approach (iterative development, reduced overheads) (Page 49).",
        "Process Improvement Cycle: Measure -> Analyze -> Change (Page 50).",
        "Process Improvement Activities: Process measurement (establishes baseline), Process analysis (identifies weaknesses), Process change (implements improvements) (Page 51).",
        "Process Metrics: Time taken, Resources required, Number of occurrences (defects) (Page 53).",
        "SEI Capability Maturity Levels: Level 1 (Initial - uncontrolled), Level 2 (Managed - repeatable), Level 3 (Defined), Level 4 (Quantitatively managed), Level 5 (Optimizing) (Page 54, 55)."
      ],
      "prerequisites": [
        "ch1"
      ],
      "content_reference": {
        "source_type": "slides",
        "file_name": "Chapter 2 Software Processes.pdf",
        "pages": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          58
        ]
      }
    },
    {
      "chapter_id": "ch3",
      "title": "Agile Software Development",
      "order": 3,
      "week_label": "Week 3",
      "learning_outcomes": [
        "Understand the nature and goals of agile development in rapid software delivery.",
        "Describe the core principles of the Agile Manifesto.",
        "Detail the practices of Extreme Programming (XP), including incremental planning, refactoring, and test-first development.",
        "Explain the role of user stories and task cards in agile requirements.",
        "Describe the Scrum agile method, its roles, terminology (ScrumMaster, Sprint, Velocity), and development cycle.",
        "Discuss the challenges of scaling agile methods to large and distributed systems and across organizations."
      ],
      "key_concepts": [
        "Rapid Software Development: Focus on fast delivery and evolution in fast-changing environments; traditional plan-driven methods are often insufficient (Page 3).",
        "Agile Development Characteristics: Inter-leaved specification, design, implementation; system developed in versions/increments; frequent delivery for evaluation; extensive tool support; minimal documentation (focus on working code) (Page 4).",
        "Plan-driven vs. Agile: Plan-driven relies on planning outputs in advance; Agile inter-leaves activities and outputs are decided through negotiation (Page 6).",
        "Agile Methods Aim: Reduce process overheads (e.g., documentation) and respond quickly to changing requirements (Page 8).",
        "Agile Manifesto Values: Individuals and interactions over processes and tools; Working software over comprehensive documentation; Customer collaboration over contract negotiation; Responding to change over following a plan (Page 9).",
        "Agile Principles: Customer involvement, Incremental delivery, People not process, Embrace change, Maintain simplicity (Page 10).",
        "Agile Applicability: Suitable for small/medium-sized product development and custom development with committed customer involvement and few external regulations (Page 11).",
        "Extreme Programming (XP): 'Extreme' approach to iterative development (new versions multiple times/day, increments every 2 weeks, all tests pass for build acceptance) (Page 13).",
        "XP Practices: Incremental planning, Small releases, Simple design, Test-first development, Refactoring, Pair programming, Collective ownership, Continuous integration, Sustainable pace, On-site customer (Page 15, 16).",
        "Refactoring: Constant code improvement (re-organization, tidying, replacement of inline code) to make future changes easier (Page 22, 23, 24).",
        "Test-first Development: Tests written before code; tests clarify requirements; relies on automated test framework (e.g., JUnit); ensures new functionality doesn't introduce errors (Page 25, 26).",
        "Test-first Problems: Programmers skip tests, difficulty testing complex UIs incrementally, difficulty judging test completeness (Page 30).",
        "Pair Programming: Programmers work together in pairs; informal review process; develops common ownership and spreads knowledge (Page 31, 32).",
        "Agile Project Management: Adapted for incremental development; focused on managing the sprint/iteration (Page 34).",
        "Scrum Phases: Initial outline planning (objectives, architecture design); Sprint cycles (develop increments); Project closure (documentation, lessons learned) (Page 35).",
        "Scrum Terminology: Development team (self-organizing, max 7 people), Potentially shippable product increment, Product backlog ('to do' list), Product owner (prioritizes features), Scrum (daily meeting), ScrumMaster (facilitator, protects team from distractions), Sprint (2-4 week iteration), Velocity (estimate of work covered per sprint) (Page 36, 37).",
        "Scrum Benefits: Manageable chunks, unstable requirements don't halt progress, improved communication, frequent customer feedback, trust and positive culture (Page 42).",
        "Distributed Scrum Needs: Videoconferencing, ScrumMaster presence, continuous integration, real-time communication (Page 43).",
        "Scaling Agile Methods: Scaling up (for large systems), Scaling out (across large organization experience) (Page 46).",
        "Agile Fundamentals in Scaling: Flexible planning, frequent releases, continuous integration, TDD, good communication (Page 46).",
        "Practical Problems with Agile: Incompatibility with traditional contracts/legal approaches, suitability mainly for new development (not maintenance), reliance on small co-located teams (problematic for worldwide distributed teams) (Page 47).",
        "Contractual Issues: Traditional contracts based on detailed specification (precluding interleaving specification/development); requires contract that pays for developer time (risk for legal departments) (Page 48).",
        "Agile Maintenance Issues: Lack of documentation, difficulty maintaining customer involvement, challenge of team continuity over long lifetime (Page 50).",
        "Agile/Plan-based Factors: System type (size, lifetime, regulation), Team factors (skills, organization, support tech), Organizational factors (culture, standard practice, customer availability) (Page 54)."
      ],
      "prerequisites": [
        "ch1"
      ],
      "content_reference": {
        "source_type": "slides",
        "file_name": "Chapter 3 Agile Software Development.pdf",
        "pages": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59,
          60,
          61,
          62,
          63,
          64,
          65,
          66
        ]
      }
    },
    {
      "chapter_id": "ch4",
      "title": "Requirements Engineering",
      "order": 4,
      "week_label": "Week 4",
      "learning_outcomes": [
        "Define Requirements Engineering (RE) and distinguish between user and system requirements.",
        "Classify and describe functional, non-functional (product, organizational, external), and domain requirements.",
        "Understand the challenges of requirements imprecision, completeness, consistency, and verifiability.",
        "Detail the iterative requirements engineering process: discovery, classification, prioritization, negotiation, and specification.",
        "Identify stakeholders in a system and techniques for requirements discovery, including interviewing and ethnography.",
        "Explain the use of user stories, scenarios, and tabular specifications for requirements documentation.",
        "Describe the structure and purpose of the Software Requirements Document (SRD).",
        "Outline requirements validation techniques: reviews, prototyping (covered in Ch2), and test-case generation.",
        "Explain the process of requirements change management (problem analysis, costing, implementation)."
      ],
      "key_concepts": [
        "Requirements Engineering (RE): Process of establishing system services and operational constraints.",
        "System Requirements: Descriptions of system services and constraints generated during RE process (Page 3).",
        "Requirement Dual Function: May serve as basis for contract bid (open to interpretation) or basis for contract itself (defined in detail) (Page 4).",
        "User Requirements: Statements in natural language/diagrams for customers (Page 6).",
        "System Requirements: Structured document with detailed descriptions of functions, services, and constraints (may be contract part) (Page 6).",
        "System Stakeholders: Any person/organization affected by the system; Types include End users, System managers/owners, External stakeholders (Page 9).",
        "Mentcare Stakeholders: Patients, Doctors, Nurses, Medical receptionists, IT staff, Medical ethics manager, Health care managers, Medical records staff (Page 10, 11).",
        "Functional Requirements: Statements of system services, reactions to inputs, and behavior in situations; may state what system should NOT do (Page 14, 15).",
        "Requirements Imprecision: Problems when functional requirements are not precisely stated (ambiguous terms like 'search') (Page 17).",
        "Requirements Completeness & Consistency: Requirements should be complete (all facilities described) and consistent (no conflicts/contradictions); practically impossible due to complexity (Page 18).",
        "Non-functional Requirements (NFRs): Constraints on system properties (reliability, response time) or development process (IDE, method); often more critical than functional requirements (Page 19).",
        "NFR Classifications: Product requirements (execution speed, reliability); Organisational requirements (process standards, implementation constraints); External requirements (interoperability, legislative, ethical) (Page 22).",
        "Goals vs. Verifiable NFRs: Goal is general intention (ease of use); Verifiable NFR is quantifiable statement (e.g., error rate per hour) (Page 24, 25).",
        "NFR Metrics: Speed (transactions/sec), Size (Mbytes), Ease of use (Training time), Reliability (Mean time to failure), Robustness, Portability (Page 26).",
        "RE Processes: Elicitation, Analysis, Validation, Management (iterative process) (Page 28, 29).",
        "Requirements Discovery: Gathering info about existing/required systems from stakeholders (Page 37).",
        "Interviewing: Formal/informal, closed/open interviews; effective interviewing involves being open-minded and prompting discussion (Page 38, 39).",
        "Interview Problems: Application specialists' jargon, difficulty articulating familiar domain knowledge (Page 40).",
        "Ethnography: Observing and analyzing how people work (social scientist); reveals richer, more complex work than models suggest; effective for existing processes but poor for new features (Page 41, 42).",
        "Focused Ethnography: Combines observation with prototyping (Page 43).",
        "Stories and Scenarios: Real-life examples of system use; basis for practical discussion (Page 45).",
        "Scenarios Structure: Description of starting situation, normal flow, what can go wrong, concurrent activities, state on completion (Page 47).",
        "Requirements Specification: Writing user and system requirements; user reqs must be understandable by non-technical users; system reqs are detailed and may be part of a contract (Page 51).",
        "Ways of Writing Specs: Natural language (expressive, universal), Structured natural language (standard form), Design description languages (abstract programming language), Graphical notations (UML, data-flow), Mathematical specifications (unambiguous, difficult for customers) (Page 52).",
        "Requirements and Design Inseparability: Design decisions (like architecture) influence requirements; regulatory requirements enforce specific design choices (Page 53).",
        "Natural Language Guidelines: Standard format, consistent mandatory/desirable language (shall/should), highlighting, avoiding jargon, inclusion of rationale (Page 55).",
        "Problems with Natural Language: Lack of clarity/precision, requirements confusion (mixing functional/non-functional), requirements amalgamation (Page 56).",
        "Structured Specifications (Form-based): Standard way of writing requirements; rigid for business systems but useful for control systems; includes Function/entity definition, Input/Output, Computation info, Action description, Pre/Post conditions, Side effects (Page 58, 59).",
        "Tabular Specification: Used to supplement natural language, useful for defining alternative courses of action (e.g., insulin pump dose calculation) (Page 62, 63).",
        "Use Cases: Scenarios in UML; identify actors/interactions; graphically modeled (Chapter 5) and supplemented by tabular descriptions (Page 64).",
        "Software Requirements Document (SRD): Official statement of system developer requirements; defines WHAT, not HOW; includes user and system specifications (Page 66).",
        "SRD Structure Sections: Preface, Introduction, Glossary, User requirements definition, System architecture, System requirements specification, System models, System evolution, Appendices, Index (Page 69, 70).",
        "Requirements Validation: Demonstrating requirements define system customer really wants; critical due to high error costs (Page 72).",
        "Requirements Checking: Validity, Consistency, Completeness, Realism, Verifiability (Page 73).",
        "Requirements Validation Techniques: Reviews (systematic manual analysis), Prototyping (executable model), Test-case generation (Page 74).",
        "Requirements Reviews: Regular checks by client/contractor staff; informal reviews resolve problems early (Page 75).",
        "Review Checks Attributes: Verifiability, Comprehensibility, Traceability, Adaptability (Page 76).",
        "Changing Requirements: Inevitable due to business/technical environment changes, different stakeholders/users (Page 78, 79).",
        "Requirements Evolution: Iterative process of initial/changed understanding leading to initial/changed requirements (Page 80).",
        "Requirements Management: Managing changing requirements; critical to track requirements/dependencies to assess impact of changes (Page 81).",
        "Requirements Management Decisions: Identification, Change management process (cost/impact analysis), Traceability policies, Tool support (Page 82).",
        "Requirements Change Management Process: Problem analysis/change specification -> Change analysis and costing (traceability) -> Change implementation (Page 83, 84)."
      ],
      "prerequisites": [
        "ch1",
        "ch2",
        "ch3"
      ],
      "content_reference": {
        "source_type": "slides",
        "file_name": "Chapter 4 Requirements Engineering.pdf",
        "pages": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59,
          60,
          61,
          62,
          63,
          64,
          65,
          66,
          67,
          68,
          69,
          70,
          71,
          72,
          73,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          82,
          83,
          84,
          85,
          86,
          87,
          88
        ]
      }
    },
    {
      "chapter_id": "ch5",
      "title": "System Modeling",
      "order": 5,
      "week_label": "Week 5",
      "learning_outcomes": [
        "Explain the purpose of system modeling and the role of UML diagrams.",
        "Describe the four system perspectives: external, interaction, structural, and behavioral.",
        "Create and interpret context models, identifying system boundaries and external dependencies.",
        "Model process flows using activity diagrams (process perspective).",
        "Model interactions using use case and sequence diagrams.",
        "Develop structural models using class diagrams, including associations, generalization, and aggregation.",
        "Develop behavioral models using activity diagrams (data-driven) and state diagrams (event-driven).",
        "Understand Model-Driven Engineering (MDE) and the Model Driven Architecture (MDA) approach, including the types of models (CIM, PIM, PSM) and their transformations."
      ],
      "key_concepts": [
        "System Modeling: Developing abstract models of a system, usually with UML notation, to understand functionality and communicate with customers (Page 3).",
        "Models of Existing/New Systems: Used for requirements engineering (clarifying current system, explaining proposed requirements) (Page 4).",
        "Model Generation: Possible to generate partial/complete system implementation from model in MDE (Page 4).",
        "System Perspectives: External (context/environment), Interaction (system/component communication), Structural (organization/data structure), Behavioral (dynamic behavior/response to events) (Page 5).",
        "UML Diagram Types: Activity diagrams, Use case diagrams, Sequence diagrams, Class diagrams, State diagrams (Page 6).",
        "Context Models: Illustrate operational context and system boundaries; affected by social/organizational concerns (Page 9).",
        "System Boundaries: Define what is inside/outside the system; position affects requirements; can be a political judgment (Page 10).",
        "Process Perspective/Models: Reveal how system is used in broader business processes; UML activity diagrams define business process models (Page 12).",
        "Interaction Models: User interaction (identify requirements), System-to-system interaction (communication problems), Component interaction (performance/dependability); use Use case and Sequence diagrams (Page 15).",
        "Use Case Modeling: Represents a discrete task involving external interaction; actors are people or systems; diagrammatic and textual forms (Page 16).",
        "Sequence Diagrams: Show sequence of interactions between actors and objects; objects listed horizontally, interactions shown by annotated arrows (Page 20).",
        "Structural Models: Display system organization/component relationships; static (design structure) or dynamic (execution organization); used for system architecture design (Page 24).",
        "Class Diagrams: Show classes and associations (relationships); Object class is general definition of a system object (Page 25).",
        "Generalization: Technique to manage complexity (higher-level classes inherit attributes/operations to lower-level subclasses); implemented using class inheritance (Page 29, 30).",
        "Aggregation Models: Show how classes (collections) are composed of other classes (part-of relationship) (Page 33).",
        "Behavioral Models: Dynamic behavior of executing system; respond to stimuli (Data or Events) (Page 36).",
        "Data-driven Modeling: For data-processing systems; shows sequence of actions processing input data/generating output; useful for end-to-end processing analysis (Page 37).",
        "Event-driven Modeling: For real-time/minimal data processing systems; shows response to external/internal events; assumes finite states and events trigger transitions (Page 40).",
        "State Machine Models: Show system behavior in response to external/internal events; states as nodes, events as arcs; Statecharts are part of UML (Page 41).",
        "Model-Driven Engineering (MDE): Models (not programs) are principal outputs; programs generated automatically from models; raises abstraction level (Page 47).",
        "MDE Usage Pros: Higher levels of abstraction, cheaper adaptation to new platforms via auto code generation (Page 48).",
        "MDE Usage Cons: Models for abstraction may not be right for implementation; cost of translators for new platforms (Page 48).",
        "Model Driven Architecture (MDA): Model-focused approach using UML subsets (precursor to MDE) (Page 49).",
        "MDA Model Types: Computation Independent Model (CIM/domain models), Platform Independent Model (PIM/operation without implementation ref), Platform Specific Models (PSM/transformation of PIM for specific platforms) (Page 50).",
        "MDA Transformations: Process involving translators between CIM, PIM, PSM, and Executable code, guided by domain/platform/language specific guidelines/patterns/rules (Page 51).",
        "Agile Methods and MDA: Extensive up-front modeling contradicts Agile Manifesto; transformations must be fully automated to fit agile process (Page 53).",
        "MDA Adoption Limits: Specialized tool support required, limited tool availability/adaptation needed, reluctance for long-lifetime systems to rely on external tool vendors (Page 54)."
      ],
      "prerequisites": [
        "ch4"
      ],
      "content_reference": {
        "source_type": "slides",
        "file_name": "Chapter 5 System Modeling.pdf",
        "pages": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          58
        ]
      }
    },
    {
      "chapter_id": "ch6",
      "title": "Architectural Design",
      "order": 6,
      "week_label": "Week 6",
      "learning_outcomes": [
        "Explain the architectural design process and the distinction between architecture 'in the small' and 'in the large'.",
        "Identify and discuss the common architectural design decisions and their impact on system non-functional characteristics (Performance, Security, Safety, Availability, Maintainability).",
        "Describe the '4 + 1 view model' for documenting software architecture (Logical, Process, Development, Physical, and Use Case views).",
        "Apply and analyze major architectural patterns, including Model-View-Controller (MVC), Layered Architecture, Repository Architecture, Client-Server Architecture, and Pipe and Filter Architecture.",
        "Recognize and apply generic application architectures: transaction processing systems and language processing systems."
      ],
      "key_concepts": [
        "Architectural Design: Understanding system organization and designing the overall structure; links design and requirements engineering (Page 3).",
        "Agility and Architecture: Early architectural design is accepted in agile processes; refactoring architecture is usually expensive (Page 4).",
        "Architecture Abstraction: Architecture in the small (individual program decomposition); Architecture in the large (complex enterprise systems, distribution across computers) (Page 6).",
        "Advantages of Explicit Architecture: Stakeholder communication, System analysis (non-functional requirements), Large-scale reuse (product-line architectures) (Page 7).",
        "Architectural Representations: Simple block diagrams (lack semantics); model semantics depend on use (Page 8).",
        "Architectural Design Decisions: Generic application template, system distribution, architectural patterns/styles, fundamental structuring approach, control strategy, organization for NFRs, documentation (Page 13).",
        "Architecture Reuse: Systems in the same domain share similar architectures; Application product lines built around core architectures; Use of architectural patterns/styles (Page 14).",
        "Architecture Characteristics vs. NFRs: Performance (localize ops, minimize comms, large components), Security (layered architecture, inner layers for assets), Safety (localize safety-critical features), Availability (redundant components, fault tolerance), Maintainability (fine-grain, replaceable components) (Page 15).",
        "Architectural Views: Multiple views/perspectives needed for design/documentation (Page 17).",
        "4 + 1 View Model: Logical view (objects/classes), Process view (interacting processes at run-time), Development view (decomposition for development), Physical view (hardware and component distribution), Use Cases/Scenarios (+1) (Page 19).",
        "Architectural Patterns: Stylized description of good, tested design practice; capture essence of architecture for reuse (Page 22).",
        "Model-View-Controller (MVC) Pattern: Separates presentation (View) and interaction (Controller) from system data (Model) (Page 23, 24).",
        "MVC Advantages: Data changes independently of representation, supports multiple presentations (Page 23).",
        "MVC Disadvantages: Added complexity for simple systems (Page 23).",
        "Layered Architecture Pattern: Organizes system into layers (abstract machines), each providing services to the layer above; supports incremental development (Page 26, 27).",
        "Layered Architecture Layers (Generic): User interface, User interface management/Authentication/Authorization, Core business logic/Application functionality, System support (OS, database) (Page 28).",
        "Layered Architecture Advantages: Replacement of layers easy if interface maintained, Redundant facilities increase dependability (Page 27).",
        "Layered Architecture Disadvantages: Difficult to separate layers cleanly, performance problems due to multiple interpretation levels (Page 27).",
        "Repository Architecture Pattern: All data managed in a central repository, accessible to all components; components interact only through repository (Page 30, 31).",
        "Repository Advantages: Component independence, easy change propagation, consistent data management/backups (Page 31).",
        "Repository Disadvantages: Single point of failure, inefficiencies in communication, difficulty distributing repository (Page 31).",
        "Client-Server Architecture Pattern: Functionality organized into services provided by stand-alone servers; clients call services (Page 33, 34).",
        "Client-Server Advantages: Servers distributed across network, general functionality available to all clients (Page 34).",
        "Client-Server Disadvantages: Single point of failure (susceptible to DoS), unpredictable performance, management problems across different organizations (Page 34).",
        "Pipe and Filter Architecture Pattern: Processing organized as discrete components (filters) performing data transformations; data flows sequentially through pipes (Page 36, 37).",
        "Pipe and Filter Advantages: Easy to understand, supports transformation reuse, matches business processes, supports sequential or concurrent systems (Page 37).",
        "Pipe and Filter Disadvantages: Agreed data format is necessary, overhead in parsing/unparsing, not suitable for interactive systems, difficult to reuse filters with incompatible data structures (Page 36, 37).",
        "Application Architectures: Generic architectures meeting organizational needs; reflect common business requirements (Page 40).",
        "Use of Application Architectures: Starting point/design checklist, organizing team work, assessing components for reuse, common vocabulary (Page 41).",
        "Application Type Examples: Data processing, Transaction processing, Event processing, Language processing (Page 42).",
        "Transaction Processing Systems: Process user requests for info or database updates; transaction is coherent sequence of operations; users make asynchronous requests (Page 44).",
        "Information Systems Architecture: Generic layered architecture (User interface, User communications, Information retrieval, System database); transaction-based systems (Page 47, 48).",
        "Web-based Information Systems: Implemented using web browsers (e-commerce); application-specific layer includes functionality like 'shopping cart' (Page 50).",
        "Server Implementation (Multi-tier): Web server (user comms/UI), Application server (logic/storage/retrieval), Database server (transaction management/data transfer) (Page 51).",
        "Language Processing Systems: Translate natural/artificial language input; include interpreter; solve problems best described by algorithms/system data (Page 52).",
        "Compiler Components: Lexical analyzer (tokens to internal form), Symbol table, Syntax analyzer (checks syntax), Syntax tree, Semantic analyzer (checks correctness), Code generator (abstract machine code) (Page 54, 55)."
      ],
      "prerequisites": [
        "ch5"
      ],
      "content_reference": {
        "source_type": "slides",
        "file_name": "Chapter 6 Architectural Design.pdf",
        "pages": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59
        ]
      }
    },
    {
      "chapter_id": "ch8",
      "title": "Software Testing",
      "order": 7,
      "week_label": "Week 7",
      "learning_outcomes": [
        "Explain the goals of program testing: validation (meets requirements) and defect testing (discovers incorrect behavior).",
        "Differentiate between verification ('building the product right') and validation ('building the right product').",
        "Describe the purpose and components of V&V confidence (system purpose, user expectations, marketing environment).",
        "Distinguish between static verification (software inspections) and dynamic verification (software testing).",
        "Detail the three stages of testing: development, release, and user testing.",
        "Explain development testing activities: unit testing (function/object/component isolation), component testing, and system testing.",
        "Design unit test cases using partition testing (equivalence partitioning) and guideline-based testing.",
        "Describe the process and benefits of Test-Driven Development (TDD), including automated testing and regression testing.",
        "Explain release testing and its goal of convincing the supplier the system is good enough for external use.",
        "Apply requirements-based testing and scenario testing to derive test cases.",
        "Describe performance testing techniques (load increase) and stress testing (failure behavior).",
        "Distinguish between Alpha, Beta, and Acceptance testing (user testing stages)."
      ],
      "key_concepts": [
        "Program Testing Goals: Demonstrate requirements are met (Validation Testing); Discover incorrect/undesirable behavior (Defect Testing) (Page 3, 4).",
        "Testing Limitation: Reveals presence of errors, NOT their absence (Page 3).",
        "Validation Testing: System performs correctly using test cases reflecting expected use (Page 5).",
        "Defect Testing: Test cases designed to expose defects (Page 5).",
        "Verification vs. Validation (V&V): Verification = 'building the product right' (conforming to specification); Validation = 'building the right product' (doing what user requires) (Page 8).",
        "V&V Confidence: Aims to establish if system is 'fit for purpose'; depends on criticality, user expectations, and marketing environment (Page 9).",
        "Software Inspections (Static Verification): Analysis of static system representation (code, documentation) to find problems; useful before implementation; effective for discovering program errors (Page 10, 12).",
        "Software Testing (Dynamic Verification): Executing product behavior with test data; focuses on operational behavior (Page 10).",
        "Advantages of Inspections: Errors cannot mask others, applicable to incomplete systems, useful for non-functional quality attributes (standards compliance, maintainability) (Page 13).",
        "Inspections vs. Testing: Complementary; inspections check conformance to specification/standards; testing checks conformance to real requirements and non-functional characteristics (Page 14).",
        "Software Testing Process: Design test cases -> Prepare test data -> Run program -> Compare results -> Test reports (Page 15).",
        "Stages of Testing: Development testing, Release testing, User testing (Page 16).",
        "Development Testing: Carried out by development team; includes Unit testing, Component testing, and System testing (Page 18).",
        "Unit Testing: Testing individual components in isolation (functions, object classes, composite components) (Page 19).",
        "Object Class Testing: Test all operations, attributes, and possible states; Inheritance complicates testing (Page 20).",
        "Automated Testing: Unit testing should be automated; uses test automation framework (e.g., JUnit) (Page 23).",
        "Automated Test Components: Setup (initialize system/inputs/expected outputs), Call (execute object/method), Assertion (compare result with expected) (Page 24).",
        "Unit Test Case Types: Reflect normal operation (expected behavior); Based on experience (abnormal inputs/common problems) (Page 25).",
        "Testing Strategies: Partition testing (identify input/output equivalence partitions); Guideline-based testing (using experience of common programmer errors) (Page 26).",
        "Equivalence Partition: Domain where program behaves equivalently for each class member (Page 27).",
        "General Testing Guidelines: Force error messages, cause buffer overflow, repeat inputs, force invalid outputs, force large/small computation results (Page 31).",
        "Component Testing: Focuses on component interface behavior; assumes unit tests are complete (Page 32).",
        "Interface Testing: Detects faults due to interface errors/invalid assumptions; Types: Parameter, Shared memory, Procedural, Message passing interfaces (Page 33).",
        "Interface Errors: Misuse (wrong parameter order), Misunderstanding (incorrect behavioral assumptions), Timing errors (different component speeds) (Page 35).",
        "System Testing: Integrates components to test the system as a whole; focuses on interactions and emergent behavior (Page 37).",
        "System and Component Testing Context: Integrates reusable, off-the-shelf, and newly developed components; often involves a separate testing team (Page 38).",
        "Use-case Testing: Use cases (system interactions) form basis for system testing; tests force interactions to occur (Page 39).",
        "Testing Policies: Define required system test coverage (e.g., test all menu functions, test combinations, test with correct/incorrect input) (Page 42).",
        "Test-Driven Development (TDD): Inter-leaves testing and code development; tests written before code; passing tests drives development (Page 44).",
        "TDD Benefits: Code coverage (at least one test per segment), Regression testing (incremental suite), Simplified debugging (obvious location of failure), System documentation (tests describe expected code behavior) (Page 47).",
        "Regression Testing: Rerunning all tests after changes to ensure previously working code isn't broken; simple and straightforward with automation (Page 48).",
        "Release Testing: Testing a system version intended for external use; primary goal is convincing supplier system is good enough; usually black-box testing (tests derived from system specification) (Page 50).",
        "Release Testing vs. System Testing: Release testing done by separate team; focuses on validation (meets requirements for external use), while system testing focuses on defect discovery (Page 51).",
        "Requirements Based Testing: Examining each requirement to develop specific tests (Page 52).",
        "Scenario Testing: Inventing a typical usage scenario (e.g., Mentcare usage) to derive test cases (Page 54, 55).",
        "Performance Testing: Part of release testing; planning tests where load is increased until performance is unacceptable (Page 56).",
        "Stress Testing: Deliberately overloading system to test failure behavior (Page 56).",
        "User Testing Types: Alpha testing (users test at developer's site), Beta testing (release available for users to experiment/report problems), Acceptance testing (customers test to decide if system is ready for deployment, primarily for custom systems) (Page 59)."
      ],
      "prerequisites": [
        "ch3",
        "ch4"
      ],
      "content_reference": {
        "source_type": "slides",
        "file_name": "Chapter 8 Software Testing.pdf",
        "pages": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59,
          60,
          61,
          62,
          63,
          64
        ]
      }
    },
    {
      "chapter_id": "ch15",
      "title": "Software Reuse",
      "order": 8,
      "week_label": "Week 8",
      "learning_outcomes": [
        "Explain why systematic software reuse is necessary for better, faster, and cheaper software development.",
        "Distinguish between different levels of reuse: system, application, component, object, and function.",
        "List and explain the key benefits and problems associated with software reuse (e.g., increased dependability, reduced costs, lack of tool support, not-invented-here syndrome).",
        "Describe the reuse landscape, including major approaches like application frameworks, product lines, and ERP systems.",
        "Define application frameworks and explain the Model-View-Controller (MVC) pattern as used in Web Application Frameworks (WAFs).",
        "Explain software product lines and the processes involved in product instance development and configuration (design time vs. deployment time).",
        "Describe application system reuse, including ERP systems and integrated application systems, and discuss associated problems."
      ],
      "key_concepts": [
        "Systematic Software Reuse: Required for better, quicker, cheaper software; switch to reuse-based development (Page 3).",
        "Levels of Reuse: System reuse (complete systems), Application reuse (incorporating family members), Component reuse (sub-systems to objects), Object and function reuse (small-scale components) (Page 4).",
        "Benefits of Reuse: Accelerated development, Effective use of specialists, Increased dependability (tested systems), Lower development costs, Reduced process risk, Standards compliance (Page 5, 6).",
        "Problems with Reuse: Cost of component library creation/maintenance/use, Finding/understanding/adapting components, Increased maintenance costs (incompatible elements), Lack of tool support, Not-invented-here syndrome (preference for writing original software) (Page 7, 8).",
        "Reuse Landscape Approaches: Application frameworks, Architectural patterns, Component-based SE (CBSE), Configurable application systems, Design patterns, ERP systems, Legacy system wrapping, Model-driven engineering, Program generators, Program libraries, Service-oriented systems, Software product lines, Systems of systems (Page 11, 12, 13, 14).",
        "Reuse Planning Factors: Development schedule, expected lifetime, team skills, software criticality/NFRs, application domain, execution platform (Page 15).",
        "Application Frameworks: Moderately large reusable entities (between system and component reuse); sub-system design with abstract/concrete classes; implemented by adding/instantiating components (Page 18).",
        "Web Application Frameworks (WAFs): Support dynamic website construction; based on Model-View-Controller (MVC) pattern (Page 19).",
        "MVC (Model-View-Controller): System infrastructure framework for GUI design; allows multiple presentations of an object and separate interactions (Page 20).",
        "WAF Features: Security, Dynamic web pages, Database support, Session management, User interaction (AJAX support) (Page 22).",
        "Extending Frameworks: Generic skeleton architecture extended by adding concrete classes/methods called in response to events (Page 23).",
        "Inversion of Control: Framework calls application-specific methods (Page 24).",
        "Framework Classes: System infrastructure frameworks, Middleware integration frameworks, Enterprise application frameworks (Page 25).",
        "Software Product Lines (Application Families): Generic functionality adapted/configured for specific contexts; common architecture/shared components (Page 27).",
        "Product Line Adaptation: Component/system configuration, adding/selecting/modifying components (Page 27).",
        "Base Applications Structure: Core components (infrastructure support, rarely modified), Configurable components (modified/configured to specialize application), Specialized domain-specific components (may be replaced) (Page 29).",
        "Product Line Architectures: Architectures must structure systems to separate subsystems for modification (Page 31).",
        "Product Line Specialization Types: Platform, Environment, Functional, Process (Page 35).",
        "Product Instance Development Process: Elicit stakeholder requirements -> Choose closest-fit instance -> Renegotiate requirements -> Adapt existing system -> Deliver new family member (Page 36, 37).",
        "Product Line Configuration: Design time configuration (developer modifies core, selects/adapts components); Deployment time configuration (customer/consultants configure generic system using configuration data) (Page 38).",
        "Deployment Time Configuration Levels: Component selection, Workflow and rule definition, Parameter definition (Page 40).",
        "Application System Reuse: Off-the-shelf software system adapted via configuration mechanisms; generic features reused in different environments (Page 42).",
        "Benefits of Application System Reuse: Rapid deployment, easier suitability judgment, avoidance of some development risks, focusing on core business, simplified technology updates (COTS vendor responsibility) (Page 43).",
        "Problems of Application System Reuse: Requirements adaptation, COTS products based on inflexible assumptions, difficulty choosing right COTS, lack of local expertise, vendor controls support/evolution (Page 44).",
        "Configurable Application Systems: Generic systems supporting specific business types/activities/enterprises (Page 45).",
        "COTS Systems Comparison: Configurable application systems (single product, system configuration focus, vendor maintenance); Application system integration (heterogeneous products, system integration focus, owner maintenance) (Page 46).",
        "ERP Systems (Enterprise Resource Planning): Generic system supporting common business processes; most common software reuse form; adapted via modules/business rules (Page 47).",
        "ERP Architecture Components: Modules (business functions), Defined business processes, Common database, Business rules (Page 49).",
        "ERP Configuration: Selecting functionality, establishing data model, defining business rules, defining external interactions, designing input/output forms, designing new business processes, setting parameters (Page 50).",
        "Integrated Application Systems: Applications integrating two or more application system products/legacy systems (Page 51).",
        "Integrated System Design Choices: Functionality selection, data exchange methods (adaptors needed), feature usage (potential duplication) (Page 52).",
        "Service-oriented Interfaces for Integration: Simplifies integration; functionality accessed via standard service interface; wrapper programmed if application doesn't offer one (Page 54)."
      ],
      "prerequisites": [
        "ch6"
      ],
      "content_reference": {
        "source_type": "slides",
        "file_name": "Chapter 15 Software Reuse.pdf",
        "pages": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          58
        ]
      }
    },
    {
      "chapter_id": "ch16",
      "title": "Component-based software engineering",
      "order": 9,
      "week_label": "Week 9",
      "learning_outcomes": [
        "Define Component-Based Software Engineering (CBSE) and its core essentials (independent components, standards, middleware, reuse development process).",
        "Explain the key characteristics of a component (Composable, Deployable, Documented, Independent, Standardized).",
        "Differentiate between 'Provides' and 'Requires' interfaces in component modeling.",
        "Describe the purpose of component models (standards for implementation, documentation, deployment) and middleware support.",
        "Detail the two main CBSE processes: 'Development for reuse' (generalizing components) and 'Development with reuse' (integrating existing components).",
        "Identify and explain supporting CBSE processes: component acquisition, component management, and component certification.",
        "Discuss component identification and validation issues, citing the Ariane 5 failure as a validation example.",
        "Explain component composition (sequential, hierarchical, additive) and the role of 'glue code' and adaptor components in reconciling interface incompatibilities.",
        "Understand how the Object Constraint Language (OCL) can be used to describe interface semantics (pre and post conditions)."
      ],
      "key_concepts": [
        "Component-Based Software Engineering (CBSE): Reuse-based approach relying on 'software components' (Page 3).",
        "Components vs. Object Classes: Components are more abstract, independent, and stand-alone service providers (Page 3).",
        "CBSE Essentials: Independent components (specified by interfaces), Component standards (for integration), Middleware (for interoperability), Reuse-geared development process (Page 4).",
        "CBSE Design Principles: Component independence, hidden implementations, communication via well-defined interfaces, replaceability if interface maintained, standard services from infrastructure (Page 5).",
        "Component Standards: Needed for communication/inter-operation; competing standards (EJB, COM/.NET, CORBA CCM) hindered uptake (Page 6).",
        "Service-Oriented SE (SOA) vs. CBSE: SOA uses executable services with 'provides' interface but not 'requires'; SOA replacing CBSE due to standards consistency (Page 7).",
        "Component Definition: Independent executable entity providing service without regard to execution location/language; interface is published (Page 9).",
        "Component Characteristics: Composable (public interfaces, self-information access), Deployable (self-contained, binary, operable on component platform), Documented (syntax/semantics specified), Independent (no reliance on specific components), Standardized (conforms to component model) (Page 11, 12).",
        "Component as Service Provider: Independent executable entity, accessed via interface, internal state never exposed (Page 13).",
        "Provides Interface: Defines services offered by component (component API) (Page 14).",
        "Requires Interface: Defines services component needs to execute (does not compromise independence) (Page 14).",
        "Component Model: Definition of standards for implementation, documentation, deployment (Page 18).",
        "Basic Elements of Component Model: Composition, Naming convention, Interface definition, Specific interfaces, Meta-data access, Usage information, Documentation, Packaging, Evolution support, Deployment and use (Page 19).",
        "Middleware Support: Provides support for executing components (platform services, application-independent support services) (Page 21).",
        "Middleware Services: Support Services (Component management, Transaction management, Resource management, Concurrency, Persistence, Security); Platform Services (Addressing, Interface definition, Exception management, Component communications) (Page 22).",
        "CBSE Processes: Support component-based SE; take possibilities of reuse into account (Page 24).",
        "Development for Reuse: Developing components/services intended for reuse; involves generalizing existing components (Page 24).",
        "Development with Reuse: Developing new applications using existing components/services (Page 24).",
        "Supporting Processes: Component acquisition (acquiring reusable component), Component management (cataloging, storing, tracking versions), Component certification (checking component quality for reuse) (Page 26).",
        "CBSE for Reuse: Focuses on component development; reusable components associated with stable domain abstractions (Page 27).",
        "Component Reusability Principles: Reflect stable domain abstractions, hide state representation, be independent, publish exceptions (Page 28).",
        "Trade-off: More general interface (greater reusability) leads to more complexity (less usability) (Page 28).",
        "Changes for Reusability: Remove application-specific methods, generalize names, broaden coverage, make exception handling consistent, add configuration interface, integrate required components (Page 29).",
        "Component Exception Handling: Components define/publish exceptions; practical problems include bloated interfaces and dependency on local handling (Page 30).",
        "Legacy System Components: Can be re-packaged for reuse by writing a wrapper component implementing interfaces (Page 31).",
        "Reusable Component Cost: Higher development cost than specific equivalents; cost should be an organizational, not project, cost (Page 32).",
        "CBSE with Reuse Involves: Developing outline requirements, Searching/modifying requirements, Searching again for better components, Composing components (Page 34).",
        "Component Identification Process: Component search -> Component selection -> Component validation (Page 36).",
        "Component Identification Issues: Trust (untrusted component may breach security), Requirements (different groups satisfy different needs), Validation (specification detail insufficient, check for malicious/unwanted functionality) (Page 37).",
        "Component Validation: Developing test cases and harness; problem is insufficient specification detail (Page 38).",
        "Ariane Launcher Failure: Example of component validation failure where assumptions made during development did not hold for the new system (Page 39).",
        "Component Composition: Assembling/integrating components to create a system; requires 'glue code' (Page 41).",
        "Types of Composition: Sequential (components executed in sequence, composing provides interfaces), Hierarchical (one component calls services of another, composing provides with requires interface), Additive (interfaces combined to create new component interface) (Page 42).",
        "Glue Code: Code allowing components to work together; resolves interface incompatibilities (Page 44).",
        "Interface Incompatibility: Parameter incompatibility, Operation incompatibility, Operation incompleteness (Page 45).",
        "Adaptor Components: Address incompatibility problems by reconciling interfaces (Page 47).",
        "Object Constraint Language (OCL): Designed to define constraints associated with UML models (pre and post condition specification) (Page 53)."
      ],
      "prerequisites": [
        "ch15"
      ],
      "content_reference": {
        "source_type": "slides",
        "file_name": "Chapter 16 Component-based software engineering.pdf",
        "pages": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59
        ]
      }
    },
    {
      "chapter_id": "ch17",
      "title": "Distributed Software Engineering",
      "order": 10,
      "week_label": "Week 10",
      "learning_outcomes": [
        "Define distributed systems and identify their key characteristics (Resource sharing, Openness, Concurrency, Scalability, Fault tolerance).",
        "Discuss design issues for distributed systems (Transparency, Openness, Scalability, Security, QoS, Failure management).",
        "Explain the concepts of Middleware and its role in coordinating diverse components and providing common services.",
        "Describe and compare Client-Server computing architectures: Two-tier (thin-client, fat-client) and Multi-tier.",
        "Describe and compare component architectural patterns: Master-Slave, Distributed Component, and Peer-to-Peer (P2P) architectures.",
        "Understand Software as a Service (SaaS) and its implementation factors (Configurability, Multi-tenancy, Scalability).",
        "Differentiate between procedural and message-based interaction models."
      ],
      "key_concepts": [
        "Distributed Systems: Collection of independent computers appearing as a single coherent system; information processing spread across several machines (Page 3).",
        "Distributed System Characteristics: Resource sharing (hardware/software), Openness (standard protocols/interoperability), Concurrency (enhanced performance), Scalability (increased throughput), Fault tolerance (ability to continue operation after failure) (Page 4).",
        "Distributed Systems Issues: Increased complexity, no single authority (impossible top-down control) (Page 6).",
        "Distributed System Design Issues: Transparency (independence from distribution characteristics), Openness (standard protocols/interoperability), Scalability (size, distribution, manageability), Security (increased attack surface, incompatible policies), Quality of Service (QoS), Failure management (resilience/recovery mechanisms) (Page 7).",
        "Transparency: Resources abstracted/addressed logically; Middleware maps logical to physical resources (Page 8).",
        "Openness Implies: Component independence, development in any programming language if standards are met, use of open standards (Web services) (Page 9).",
        "Scalability: Scaling-up (more powerful system) vs. Scaling-out (more system instances) (Page 10).",
        "Types of Attack (Distributed Systems): Interception (loss of confidentiality), Interruption (DoS), Modification (data/service change), Fabrication (generating false info) (Page 12).",
        "Quality of Service (QoS): System ability to deliver dependable service with acceptable response time/throughput; critical for time-critical data (Page 13).",
        "Failure Management: Systems must be resilient, discover component failure, continue delivery, and recover (Page 14).",
        "Models of Interaction: Procedural interaction (RPC, component calls service and waits for response), Message-based interaction (sending info, no necessity to wait) (Page 15).",
        "Remote Procedure Calls (RPC): Procedural comms using middleware to intercept calls to remote components; problem is need for caller/callee availability/reference knowledge (Page 18).",
        "Message Passing: Component creates message -> Middleware sends to receiver -> Receiver parses/computes/creates response message; sender/receiver communicate via middleware (Page 19).",
        "Middleware: Software managing diverse components (different languages/processors); ensures communication/data exchange; provides location transparency and common services (Page 20, 22).",
        "Client-Server Computing: Distributed systems accessed over Internet; user interacts with local/mobile app, communicating with remote server (Page 24).",
        "Client-Server Architectural Layers: Presentation, Data handling, Application processing, Database (Page 27, 28).",
        "Two-Tier Architectures: Single logical server + indefinite clients; Thin-client (presentation layer on client, others on server); Fat-client (some/all application processing on client) (Page 33).",
        "Thin Client Model Use: Migrating legacy systems, data-intensive apps (Web browsing) (Page 35).",
        "Fat Client Model Use: New C/S systems with known client capabilities, computationally intensive apps, mobile apps (cached info) (Page 36).",
        "Thin/Fat Client Blurring: JavaScript/mobile apps allow local processing; few purely thin-client applications remain (Page 38).",
        "Multi-Tier Client-Server Architecture: Layers (presentation, data handling, processing, database) separated into processes on different processors; avoids scalability/management problems of two-tier models (Page 39).",
        "Distributed Component Architectures: No client/server distinction; each entity is a component providing/receiving services; communication via middleware (Page 43).",
        "Distributed Component Benefits: Delay service provision decisions, open architecture, flexible and scalable, dynamic reconfiguration (Page 45).",
        "Distributed Component Disadvantages: Complex to design, standardized middleware never accepted (incompatible vendor middleware); being replaced by SOA (Page 47).",
        "Peer-to-Peer (P2P) Architectures: Decentralized systems; computations carried out by any node (File sharing, Messaging, Payments, Databases, Computation) (Page 48, 49).",
        "P2P Use Cases: Computationally-intensive systems where processing can be separated; systems involving information exchange without central storage (Page 54).",
        "P2P Security Issues: Lack of central management (spam/malware risk), communications require careful setup to protect local info (Page 55).",
        "Software as a Service (SaaS): Hosting software remotely, accessed over Internet (web browser); software owned/managed by provider; payment based on use (Page 56, 57).",
        "SaaS vs. SOA: SaaS is long transactions (editing document); SOA (Service-oriented architecture) uses stateless, short-transaction services (Page 58).",
        "SaaS Implementation Factors: Configurability (for organization-specific requirements), Multi-tenancy (efficient sharing while appearing as sole use), Scalability (accommodate large number of users) (Page 59, 64).",
        "Service Configuration Elements (SaaS): Branding (organization-specific interface), Business rules/workflows, Database extensions, Access control (Page 61).",
        "Multi-tenancy: Many users access same system efficiently; absolute separation between functionality and data (Page 62)."
      ],
      "prerequisites": [
        "ch6",
        "ch16"
      ],
      "content_reference": {
        "source_type": "slides",
        "file_name": "Chapter 17 Distributed software engineering.pdf",
        "pages": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59,
          60,
          61,
          62,
          63,
          64,
          65,
          66
        ]
      }
    },
    {
      "chapter_id": "ch18",
      "title": "Service-oriented Software Engineering",
      "order": 11,
      "week_label": "Week 11",
      "learning_outcomes": [
        "Define web services and explain the benefits of a service-oriented approach (SOA).",
        "Describe SOA key standards: SOAP (messaging), WSDL (interface definition), and WS-BPEL (workflow/composition).",
        "Explain the principles of RESTful web services (Representational State Transfer) as a simpler alternative to SOAP/WSDL.",
        "Differentiate between resource operations (CREATE, READ/GET, UPDATE/PUT, DELETE) and resource access using URLs in REST.",
        "Outline the service engineering process: identification, design, implementation, and deployment.",
        "Classify services into utility, business, and coordination types, and distinguish between task-oriented and entity-oriented services.",
        "Describe service composition and the role of workflows (e.g., BPMN notation) in creating composite services and applications.",
        "Discuss challenges in testing service compositions due to black-box external services and unpredictable non-functional behavior."
      ],
      "key_concepts": [
        "Web Service Definition: An instance of a general service notion; provision of service independent of application using it (Page 3).",
        "Reusable Services: Independent, loosely coupled reusable components; accessed using standard Internet and XML-based protocols (Page 4).",
        "Benefits of SOA: Services offered inside/outside organization, service provider publicizes information, delayed binding (reactive applications), opportunistic construction, usage-based payment, smaller applications (offloading processing to external services) (Page 5, 6).",
        "Service-Oriented Architecture (SOA): Developing distributed systems where components are stand-alone services; services execute on different computers/providers; uses standard protocols (Page 12).",
        "SOA Interaction Components: Service registry (publish/find), Service requestor (find/bind/SOAP), Service provider (publish/WSDL) (Page 13).",
        "SOA Benefits: Local/outsourced provision, language-independent services, preservation of legacy systems, inter-organizational computing (Page 14).",
        "SOA Key Standards: SOAP (Simple Object Access Protocol - message exchange), WSDL (Web Service Definition Language - interface/binding definition), WS-BPEL (Web Services Business Process Execution Language - workflow language for composition) (Page 15).",
        "Web Service Standards Stack: XML technologies, Support (WS-Security), Process (WS-BPEL), Service definition (UDDI, WSDL), Messaging (SOAP), Transport (HTTP, HTTPS, SMTP) (Page 16).",
        "Service vs. CBSE Component: Service is independent, no 'requires' interface; relies on message-based communication in XML (Page 18).",
        "WSDL Components: 'What' (Interface: operations, message format), 'How' (Binding: abstract interface to concrete protocols), 'Where' (Endpoint: location of service implementation) (Page 21).",
        "RESTful Web Services (Representational State Transfer): Architectural style for transferring representations of resources; simpler, lower overhead than SOAP/WSDL (Page 25).",
        "REST Resource: Fundamental element, a data element (catalog, medical record) with multiple representations (formats) (Page 26).",
        "REST Resource Operations: Create (POST), Read (GET), Update (PUT), Delete (DELETE) (Page 27, 29).",
        "Resource Access (REST): Data exposed and accessed using URL; GET retrieves resource/items (Page 30).",
        "REST Disadvantages: Difficult to design for complex interfaces/non-simple resources, lack of interface description standards (reliance on informal docs), must implement own infrastructure (monitoring QoS/reliability) (Page 32).",
        "Service Engineering Process: Developing reusable services; requires reusable abstraction, robust/reliable design, and documentation (Page 35).",
        "Service Engineering Stages: Service candidate identification, Service design (logical/implementation interfaces), Service implementation and deployment (implement, test, make available) (Page 37).",
        "Service Candidate Identification: Understanding business processes to identify reusable services (Page 38).",
        "Fundamental Types of Service: Utility services (general functionality), Business services (specific business function), Coordination services (composite processes) (Page 38).",
        "Task-oriented Services: Associated with activity; Coordination services are always task-oriented (Page 39).",
        "Entity-oriented Services: Associated with business entity (like objects); Utility/business services may be entity- or task-oriented (Page 39).",
        "Service Interface Design: Minimize messages exchanged; include service state information in messages (Page 47).",
        "Interface Design Stages: Logical interface design (operations, exceptions), Message design (SOAP, UML/XML messages), Interface design (REST, mapping operations to resources) (Page 48).",
        "Service Implementation and Deployment: Programming using standard/workflow language; testing with input/output messages; deployment involves publicizing and installing on web server (Page 54).",
        "Legacy System Services: Implemented by providing a service interface to existing legacy systems (Page 55).",
        "Service Descriptions: Information about business/contact (for trust), informal functionality description (for users), usage description (SOAP/RESTful), subscription information (updates) (Page 56).",
        "Service Composition: Assembling/configuring existing services to create composite services/applications; often based on a workflow (Page 58).",
        "Service Construction by Composition Process: Formulate outline workflow, Discover services, Select possible services, Refine workflow, Create workflow program (e.g., WS-BPEL), Test completed service (Page 60, 61, 62).",
        "Workflow Design/Implementation: WS-BPEL (XML standard, often unreadable); Graphical notations (BPMN) are more readable; used with SOAP-based and RESTful services (Page 63).",
        "Testing Service Compositions: Difficult because external services are 'black-boxes'; source code testing techniques unusable (Page 66).",
        "Service Testing Problems: External services may be modified (invalidating tests), dynamic binding leads to unreliability, non-functional behavior is unpredictable (load dependent), expensive testing if paid by use, difficulty simulating compensating actions (Page 67)."
      ],
      "prerequisites": [
        "ch17"
      ],
      "content_reference": {
        "source_type": "slides",
        "file_name": "Chapter 18 Service-oriented software engineering.pdf",
        "pages": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59,
          60,
          61,
          62,
          63,
          64,
          65,
          66,
          67,
          68,
          69
        ]
      }
    },
    {
      "chapter_id": "ch21",
      "title": "Real-time Software Engineering",
      "order": 12,
      "week_label": "Week 12",
      "learning_outcomes": [
        "Define embedded and real-time systems, distinguishing between hard and soft real-time systems.",
        "List the characteristics and architectural considerations for embedded systems (continuous operation, unpredictable interactions, safety/reliability dominance).",
        "Differentiate between periodic and aperiodic stimuli in reactive systems.",
        "Describe the system elements of real-time control systems (Sensor control, Data processor, Actuator control) and their coordination needs (mutual exclusion).",
        "Explain the importance of timing analysis in real-time systems, focusing on deadlines, frequency, and execution time.",
        "Apply the concept of state machine models (UML state diagrams) to describe embedded system behavior.",
        "Identify and apply architectural patterns for embedded systems: Observe and React, Environmental Control, and Process Pipeline.",
        "Describe the components and management functions of a Real-Time Operating System (RTOS): process management, scheduling, and interrupt servicing."
      ],
      "key_concepts": [
        "Embedded Software: Software reacting to events generated by hardware; typically in read-only memory; responds in real time (Page 3).",
        "Responsiveness: Critical difference in real-time systems; correctness depends on the response and time taken to generate it (Page 4).",
        "Real-time System Definition: Correct functioning depends on results and the time they are produced (Page 5).",
        "Soft Real-time System: Operation degraded if timing requirements are missed (Page 5).",
        "Hard Real-time System: Operation incorrect if timing specification is missed (Page 5).",
        "Embedded System Characteristics: Continuous running, unpredictable environment interactions, physical limitations, direct hardware interaction, safety/reliability dominance (Page 6).",
        "Embedded System Design: Systems engineering process considering design/performance of hardware; hardware vs. software capability implementation decisions; early consideration of low-level timing/support software (Page 8).",
        "Reactive Systems: Real-time systems reacting to stimuli within specified time (Page 9).",
        "Types of Stimuli: Periodic stimuli (predictable intervals, e.g., sensor polling), Aperiodic stimuli (irregular/unpredictable, e.g., interrupts from power failure) (Page 9, 11).",
        "Real-time System Architecture: Must allow for fast switching between stimulus handlers; designed as cooperating processes controlled by a real-time executive (Page 13).",
        "System Elements (Real-time): Sensor control processes (collect/buffer info), Data processor (computes system response), Actuator control processes (generates control signals) (Page 15).",
        "Process Coordination: Processes share info/resources; coordination mechanisms ensure mutual exclusion (Page 17).",
        "Mutual Exclusion: Ensures producer/consumer processes do not access the same buffer element simultaneously (Page 18).",
        "Real-time System Modelling: State models/UML state diagrams used to describe state transitions triggered by stimuli (Page 20).",
        "Real-time Programming: Languages must allow hardware access and predictable timing (e.g., C over Java due to performance overhead in OOP) (Page 23).",
        "Architectural Patterns for Embedded Systems: Observe and React (monitor sensors for exceptional conditions), Environmental Control (sensors/actuators change environment), Process Pipeline (data transformation sequence) (Page 25).",
        "Observe and React Pattern Processes: Observer, Analysis, Display, Alarm, Reactor (Page 26, 27).",
        "Environmental Control Pattern Processes: Monitor, Control, Display, Actuator Driver, Actuator monitor (Page 30, 31).",
        "Process Pipeline Pattern: Processes linked by synchronized buffers; Producer, Buffer, Consumer processes; used in data acquisition/multimedia systems (Page 33).",
        "Timing Analysis: Calculates how often processes must execute to ensure timely processing of inputs/responses (Page 37).",
        "Factors in Timing Analysis: Deadlines (time by which response must be produced), Frequency (times per second process must execute), Execution time (time to process stimulus/produce response) (Page 38).",
        "Power Failure Timing Example: Checking process scheduled to run every 4ms; battery backup takes 16ms to become operational (Page 40).",
        "Real-time Operating Systems (RTOS): Specialized OS managing processes in RTS; responsible for process/resource allocation; generally excludes file management (Page 47).",
        "RTOS Components: Real-time clock (scheduling info), Interrupt handler (manages aperiodic requests), Scheduler (chooses next process), Resource manager (allocates memory/processor), Dispatcher (starts process execution) (Page 48, 50).",
        "Non-stop System Components: Configuration manager (dynamic reconfiguration), Fault manager (detects faults, initiates backup actions) (Page 49).",
        "Process Management (RTOS): Manages concurrent processes; periodic processes executed at pre-specified intervals; considers process period and deadline (Page 51).",
        "Process Priority: Interrupt level priority (fastest response), Clock level priority (periodic processes) (Page 52).",
        "Interrupt Servicing: Control transferred to pre-determined memory location containing instruction for interrupt service routine (ISR); ISRs must be short/fast (Page 53).",
        "Periodic Process Servicing: Real-time clock interrupt schedules process manager for periodic processes (Page 54).",
        "Process Switching: Scheduler chooses next process based on priority; Resource manager allocates resources; Dispatcher loads process and starts execution (Page 56).",
        "Scheduling Strategies: Non pre-emptive (runs to completion or block); Pre-emptive (higher priority process stops execution) (Page 57).",
        "Scheduling Algorithms: Round-robin, Rate monotonic, Shortest deadline first (Page 57)."
      ],
      "prerequisites": [
        "ch6",
        "ch17"
      ],
      "content_reference": {
        "source_type": "slides",
        "file_name": "Chapter 21- Real-time Software Engineering.pdf",
        "pages": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59
        ]
      }
    },
    {
      "chapter_id": "ch22",
      "title": "Project Management (People & Risk)",
      "order": 13,
      "week_label": "Week 13",
      "learning_outcomes": [
        "Define software project management and its success criteria (time, budget, expectations, team coherence).",
        "Identify the distinctions of software management (intangible product, 'one-off' projects, variable processes).",
        "List and describe universal management activities (Project Planning, Risk management, People management, Reporting, Proposal writing).",
        "Define software risk management and its process: identification, analysis, planning, and monitoring.",
        "Classify risks into project, product, and business risks and provide examples.",
        "Explain risk strategies: avoidance, minimization, and contingency planning.",
        "Explain the importance of people management and motivational theories (Human needs hierarchy, Basic, Social, Esteem, Self-realization needs).",
        "Describe key people management factors (Consistency, Respect, Inclusion, Honesty) and personality types (Task-oriented, Interaction-oriented, Self-oriented).",
        "Explain the concept and advantages of group cohesiveness and team spirit for performance."
      ],
      "key_concepts": [
        "Software Project Management: Ensuring software delivery on time/schedule and meeting requirements/constraints (Page 3).",
        "Project Success Criteria: Deliver on time, stay within budget, meet customer expectations, maintain a coherent team (Page 4).",
        "Software Management Distinctions: Product is intangible (cannot see progress), many projects are 'one-off' (difficult to anticipate problems), processes are variable/organization specific (hard to reliably predict problems) (Page 5).",
        "Factors Influencing Project Management: Company size, software customers/size/type, organizational culture, software development processes (Page 6).",
        "Universal Management Activities: Project planning (estimating, scheduling, task assignment, Chapter 23), Risk management (assessing, monitoring, mitigating), People management (team selection, effective working), Reporting (progress to stakeholders), Proposal writing (winning contracts) (Page 7, 8).",
        "Risk Management: Identifying risks and planning to minimize their effect (Page 10).",
        "Software Risk Management Importance: Due to inherent uncertainties (vague requirements, changes, estimation difficulties, individual skill differences) (Page 10).",
        "Risk Management Process: Risk identification -> Risk analysis -> Risk planning -> Risk monitoring (Page 13, 14).",
        "Risk Classification Dimensions: Type of risk (technical, organizational), What is affected (Project, Product, Business risks) (Page 11).",
        "Project Risks: Affect schedule or resources (e.g., staff turnover, management change, hardware unavailability) (Page 12).",
        "Product Risks: Affect quality or performance (e.g., requirements change, size underestimate, tool underperformance) (Page 12).",
        "Business Risks: Affect the organization developing/procuring software (e.g., technology change, product competition) (Page 12).",
        "Risk Identification: Team activity or individual experience; checklist used (Technology, Organizational, People, Requirements, Estimation risks) (Page 15).",
        "Risk Analysis: Assess probability (very low to very high) and seriousness/consequences (catastrophic to insignificant) (Page 17).",
        "Risk Planning Strategies: Avoidance (reduce probability), Minimization (reduce impact), Contingency plans (deal with risk if it arises) (Page 20).",
        "Risk Monitoring: Regularly assessing if risk probability or effects have changed; discussed in management progress meetings (Page 24).",
        "Risk Indicators: Estimation (schedule/defect failure), Organizational (gossip, lack of action), People (poor morale, high turnover), Requirements (change requests, complaints), Technology (late delivery, problems), Tools (reluctance to use, complaints) (Page 25).",
        "People Management: People are organizations most important assets; poor management contributes to project failure (Page 27).",
        "People Management Factors: Consistency (comparable treatment), Respect (different skills recognized), Inclusion (involve members, views considered), Honesty (about progress/problems) (Page 28).",
        "Motivating People: Organizing work/environment effectively (Page 29).",
        "Types of Motivation (Needs Hierarchy): Basic needs (physiological, safety), Personal needs (respect, self-esteem), Social needs (acceptance in group) (Page 29, 30).",
        "Need Satisfaction in SE: Social (communal facilities, informal communication), Esteem (recognition, rewards), Self-realization (training, responsibility) (Page 31).",
        "Personality Types (Motivations): Task-oriented (motivated by work itself), Self-oriented (motivated by personal success/recognition), Interaction-oriented (motivated by co-workers) (Page 35, 36).",
        "Motivation Balance: Individual motivations mix elements; balance changes with circumstances; group/culture also motivates (Page 37).",
        "Teamwork in SE: Most SE is group activity; projects cannot be completed by one person alone (Page 39).",
        "Cohesive Group: Members consider group more important than individual (Page 40).",
        "Cohesion Advantages: Develop quality standards, mutual learning/knowledge sharing, continuity if member leaves, encouragement of refactoring/improvement (Page 40).",
        "Team Effectiveness Factors: People mix (diverse skills like negotiation, programming, testing), Group organization (allows best contribution), Technical/managerial communications (Page 42).",
        "Selecting Group Members: Manager creates cohesive group with balance of technical skills and personalities (Page 43).",
        "Group Composition: Balance of personality types needed (Task, Self, Interaction); interaction-oriented people detect/defuse tensions (Page 45).",
        "Group Organization: Affects decision-making, information exchange, and external interactions (Page 47).",
        "Agile Group Organization: Small groups informal/without rigid structure; formal structure inhibits information exchange (Page 48, 49).",
        "Group Communications: Essential for effective work; exchanges status/decisions/changes; strengthens cohesion (Page 50).",
        "Factors Influencing Group Communications: Group size (larger = harder communication), Group structure (informal better than hierarchical), Group composition (mixed personalities better), Physical work environment (organization helps comms) (Page 51)."
      ],
      "prerequisites": [
        "ch3"
      ],
      "content_reference": {
        "source_type": "slides",
        "file_name": "Chapter 22 Project management.pdf",
        "pages": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53
        ]
      }
    },
    {
      "chapter_id": "ch23",
      "title": "Project Planning",
      "order": 14,
      "week_label": "Week 14",
      "learning_outcomes": [
        "Explain the project planning process and its stages (proposal, startup, development).",
        "Discuss software pricing factors (contractual terms, cost uncertainty, financial health, market opportunity, requirements volatility) and strategies (underpricing, increased pricing, pricing to win).",
        "Describe the purpose and components of the Project Plan in plan-driven development.",
        "Detail the activities of project scheduling (task splitting, resource allocation, concurrency, dependency minimization).",
        "Use graphical notations (Bar charts, Activity networks) to represent project schedules, milestones, and deliverables.",
        "Explain the process of agile planning, including release planning, iteration planning, and the 'planning game' (story-based planning, velocity).",
        "Differentiate between experience-based and algorithmic cost modeling techniques.",
        "Describe the COCOMO II cost model, its sub-models (Application Composition, Early Design, Reuse, Post-architecture), and formulas for effort and duration estimation."
      ],
      "key_concepts": [
        "Project Planning: Breaking down work, assigning tasks, anticipating problems, creating solutions (Page 3).",
        "Project Plan Purpose: Communicate work structure, track progress (Page 3).",
        "Planning Stages: Proposal stage (bidding/pricing), Project startup phase (staff/increments/resources/monitoring), Periodically throughout project (revision based on experience/monitoring) (Page 4).",
        "Proposal Planning: Setting price; involves estimating staff, hardware, software, travel, training, and effort costs (Page 5).",
        "Project Startup Planning: Detailed planning for budget/staffing when system requirements are known; defines resource allocation/monitoring (Page 6).",
        "Development Planning: Regular amendment of plan/schedule/cost-estimate/risks as project progresses (Page 7).",
        "Software Pricing Factors: Contractual terms (source code ownership/reuse), Cost estimate uncertainty (contingency budget), Financial health (lower price to win contract), Market opportunity (low price to enter market), Requirements volatility (high price for changes) (Page 10, 11).",
        "Pricing Strategies: Under pricing (gain contract/market access), Increased pricing (fixed-price contracts/unexpected risks), Pricing to win (reduce functionality to meet buyer's price/charge higher for changes) (Page 12, 13).",
        "Plan-driven Development: Development planned in detail; uses traditional engineering project management techniques (Page 15).",
        "Plan-driven Pros/Cons: Pros (early planning addresses organizational issues, discovers dependencies); Cons (early decisions often revised due to environment changes) (Page 16).",
        "Project Plan Sections: Introduction, Project organization, Risk analysis (Chapter 22), Hardware/software resource requirements, Work breakdown, Project schedule, Monitoring/reporting mechanisms (Page 17).",
        "Project Plan Supplements: Configuration management plan (Ch 25), Deployment plan, Maintenance plan, Quality plan (Ch 24), Validation plan (Page 18).",
        "Planning Process Iteration: Iterative process starting at startup; plan changes inevitable due to new info/changing business goals (Page 19, 20).",
        "Planning Assumptions: Must be realistic (not optimistic); assume problems arise; include contingency (Page 21).",
        "Risk Mitigation: Initiate actions to reduce risks of project failure; may involve renegotiating constraints/deliverables (Page 22).",
        "Project Scheduling: Organizing work into tasks, estimating time/effort/resources, and execution sequence (Page 24).",
        "Scheduling Activities: Split into tasks (time/resource estimate), Organize tasks concurrently, Minimize task dependencies (Page 25).",
        "Scheduling Problems: Difficulty estimating difficulty/cost of problems, productivity not proportional to number of people, adding people to late project adds communication overheads (Page 27).",
        "Schedule Presentation: Graphical notations (Bar charts for time/resources, Activity networks for dependencies) (Page 28).",
        "Project Activities (Tasks) Elements: Duration (calendar time), Effort estimate (person-days/months), Deadline, Defined end-point (document, meeting, test completion) (Page 29).",
        "Milestones: Points in schedule to assess progress (e.g., system handover for testing) (Page 30).",
        "Deliverables: Work products delivered to customer (e.g., requirements document) (Page 30).",
        "Agile Planning: Iterative, flexible planning for incremental delivery; functionality decided during development based on customer priorities (Page 35).",
        "Agile Planning Stages: Release planning (features for multi-month release), Iteration planning (2-4 weeks work for next increment) (Page 36).",
        "Approaches to Agile Planning: Scrum (Chapter 3), Planning Game (XP) (Page 37).",
        "Story-based Planning: User stories prioritized/ranked by team for implementation time; 'effort points' assigned; 'velocity' (implemented effort points/day) used for estimation (Page 38).",
        "Task Allocation (Agile): Developers break stories into 416 hour tasks; developers sign up for tasks; benefits: team overview, ownership, motivation (Page 41).",
        "Software Delivery (Agile): Increment delivered at end of each iteration; scope reduced if features cannot be completed; delivery schedule never extended (Page 42).",
        "Agile Planning Difficulties: Reliance on customer availability/involvement; customers may prefer traditional plans (Page 43).",
        "Agile Planning Applicability: Works well with small, stable, co-located teams; problematic for large, geographically distributed teams (Page 44).",
        "Estimation Techniques: Experience-based techniques (manager judgment based on past projects), Algorithmic cost modeling (formulaic approach based on product attributes/process characteristics) (Page 46).",
        "Estimate Uncertainty: Uncertainty decreases as development progresses (Feasibility -> Requirements -> Design -> Code -> Delivery) (Page 47).",
        "Experience-based Problems: New project may lack commonality with past projects; fast-changing technology limits relevance of past experience (Page 49).",
        "Algorithmic Cost Modelling: Effort = A  Size^B  M; Size often measured by code size (KLOC); A, B, M are organization-dependent constants/multipliers (Page 50).",
        "Estimation Accuracy: Size only known accurately when finished; influenced by reuse, language, distribution; estimates become more accurate as process progresses (Page 51).",
        "Algorithmic Model Effectiveness: Systematic way to estimate, but complex/difficult to use; limited application outside defense/aerospace (Page 52).",
        "COCOMO II Cost Modeling: Empirical model based on project experience; independent model (not vendor tied); accounts for development approaches/reuse (Page 54).",
        "COCOMO II Sub-models: Application composition model (prototyping/extensive reuse projects), Early design model (when requirements agreed, before design), Reuse model (integrating reusable components), Post-architecture model (after architecture design) (Page 55, 56).",
        "Application Composition Model Formula: PM = (NAP  (1 - %reuse/100)) / PROD; PM=effort (person-months), NAP=application points, PROD=productivity (Page 57).",
        "Early Design Model Formula: PM = A  Size^B  M; M=Multipliers (PERS, RCPX, RUSE, PDIF, PREX, FCIL, SCED); B varies based on novelty, flexibility, risk management, process maturity (Page 59, 60).",
        "Reuse Model Estimates: Generated code (PM = (ASLOC * AT/100)/ATPROD); Integrated code (ESLOC = ASLOC * (1-AT/100) * AAM) (Page 62, 63).",
        "Post-architecture Level: Uses modified Early Design Model formula with 17 multipliers; code size estimate includes new code, equivalent reuse code, and modified code (Page 64).",
        "Exponent Term (B): Depends on 5 scale factors (Precedenteness, Development flexibility, Architecture/risk resolution, Team cohesion, Process maturity) (Page 65, 66).",
        "Multipliers: Product attributes (required characteristics), Computer attributes (hardware constraints), Personnel attributes (experience/capabilities), Project attributes (development project characteristics) (Page 67).",
        "Project Duration (TDEV): Estimated using TDEV = 3  (PM)^(0.33+0.2*(B-1.01)); predicts nominal schedule (Page 70).",
        "Staffing Requirements: Number of people varies by phase; rapid build-up correlates with schedule slippage (Page 71)."
      ],
      "prerequisites": [
        "ch22"
      ],
      "content_reference": {
        "source_type": "slides",
        "file_name": "Chapter 23 Project Planning.pdf",
        "pages": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59,
          60,
          61,
          62,
          63,
          64,
          65,
          66,
          67,
          68,
          69,
          70,
          71,
          72,
          73,
          74
        ]
      }
    },
    {
      "chapter_id": "ch24",
      "title": "Quality Management",
      "order": 15,
      "week_label": "Week 15",
      "learning_outcomes": [
        "Define software quality management and its three main concerns (organizational, project process, quality plan).",
        "Explain the concept of software quality beyond specification conformance, focusing on 'fitness for purpose' and non-functional characteristics.",
        "List and classify software quality attributes (Safety, Security, Reliability, etc.).",
        "Describe the purpose and components of software standards (product and process standards) and their importance for quality assurance.",
        "Explain the process and types of software reviews and inspections (defect removal, progress assessment, quality reviews).",
        "Detail the phases of the review process (pre-review, meeting, post-review) and inspection checklists (Data, Control, I/O, Interface, Storage, Exception faults).",
        "Discuss Quality Management (QM) in the context of agile development (informal culture, reliance on good practices, opposition to ISO 9001 overheads).",
        "Define software measurement and metrics, distinguishing between process metrics and product metrics (static vs. dynamic).",
        "Explain the challenges of software measurement in industry (lack of standards, process immaturity, measurement ambiguity)."
      ],
      "key_concepts": [
        "Software Quality Management: Ensuring the required level of quality is achieved (Page 3).",
        "Quality Management Concerns: Organizational (framework/standards), Project process (application/checking specific processes), Quality plan (goals, processes, standards) (Page 3).",
        "Quality Management Activities: Independent check on development process; checks deliverables against standards/goals; quality team should be independent (Page 4).",
        "Quality Planning: Sets desired qualities, defines assessment process, sets organizational standards (Page 6).",
        "Quality Plan Structure: Product introduction/plans, Process descriptions, Quality goals, Risks and risk management (Page 7).",
        "Quality Definition: Simplistically, meeting specification; problematical for software (tension between customer/developer requirements, ambiguity); focus on 'fitness for purpose' (Page 10).",
        "Software Fitness for Purpose: Properly tested, dependable, acceptable performance, usable, well-structured/understandable, adherence to standards (Page 11).",
        "Subjective Quality: Largely based on non-functional characteristics (reliability, speed); functionality can often be worked around (Page 12).",
        "Software Quality Attributes: Safety, Security, Reliability, Resilience, Robustness, Understandability, Testability, Adaptability, Modularity, Complexity, Portability, Usability, Reusability, Efficiency, Learnability (Page 13).",
        "Quality Conflicts: Impossible to optimize for all attributes (e.g., robustness vs. performance) (Page 14).",
        "Process and Product Quality: Product quality influenced by process quality; complex relationship due to individual skills, external factors (novelty, accelerated schedule) (Page 15).",
        "Process-based Quality Cycle: Define process -> Develop product -> Assess product quality -> Improve process/Standardize process (Page 16).",
        "Quality Culture: Commitment from everyone to high product quality; teams take responsibility; support for intangible aspects/professional behavior (Page 17).",
        "Software Standards: Define required product/process attributes; play important role in QM (Page 19).",
        "Importance of Standards: Encapsulation of best practice, framework for defining quality, continuity for new staff (Page 20).",
        "Product Standards: Apply to software product (document structure, coding, standard headers) (Page 21).",
        "Process Standards: Define processes to be followed (specification, design, validation, tools) (Page 21).",
        "Problems with Standards: Not seen as relevant/up-to-date, bureaucratic form filling, lack of tool support (Page 23).",
        "Standards Development: Involve practitioners (understand rationale), regular review, specialized tool support needed for detailed standards (Page 24).",
        "ISO 9001: International framework for developing QM systems; applies to organizations designing, developing, maintaining products (Page 25).",
        "ISO 9001 Core Processes: Business acquisition, Design and development, Business management, Supplier management, Product delivery processes, Supporting processes (Page 26).",
        "ISO 9001 Certification: External body certifies conformity of organizational quality manual; inadequate because it equates quality to conformance to standards (Page 28, 29).",
        "Reviews and Inspections: Group examines process/system/documentation to find problems; 'signed off' at review (Page 31).",
        "Types of Review: Inspections (defect removal/product), Reviews for progress assessment (product/process), Quality reviews (product/standards) (Page 31).",
        "Quality Reviews: Group examines system/documentation (code, designs, test plans) (Page 32).",
        "Review Process Phases: Pre-review (planning/preparation), Review meeting ('walk through'), Post-review (address problems/issues) (Page 33, 34).",
        "Distributed Reviews: Remote reviewing supported by shared documents and annotation (Page 35).",
        "Program Inspections (Peer Reviews): Engineers examine source code to find anomalies/defects; effective for program errors (Page 36).",
        "Inspection Checklists: Used to drive inspection; programming language dependent; examples: Initialisation, Constant naming, Loop termination (Page 37).",
        "Inspection Checklist Fault Classes: Data faults, Control faults, Input/output faults, Interface faults, Storage management faults, Exception management faults (Page 38, 39).",
        "Agile QM: Informal rather than document-based; relies on quality culture; opposes ISO 9001 bureaucratic overheads (Page 41).",
        "Shared Agile Practice (QM): Check before check-in (programmer code reviews), Never break the build (test code changes against whole system), Fix problems when seen (fix other developer's code directly) (Page 42).",
        "Reviews in Agile: Informal; Scrum uses Sprint Review; Extreme Programming uses Pair Programming (Page 43).",
        "Pair Programming (QM): Two people develop code together; informal review; develops deep knowledge; finds bugs difficult to find in formal inspections (Page 44).",
        "Pair Programming Weaknesses: Mutual misunderstandings, Pair reputation (reluctance to slow progress), Working relationships (reluctance to criticize work partners) (Page 45).",
        "Agile QM and Large Systems: Minimal documentation impractical for external customers, distributed teams, or long-lifetime systems (Page 46).",
        "Software Measurement: Deriving a numeric value for software product/process attribute; allows objective comparisons (Page 48).",
        "Software Metric: Any type of measurement related to system, process, or documentation; allows quantification; predicts attributes/identifies anomalous components (Page 49).",
        "Types of Process Metric: Time taken for process completion, Resources required (effort, travel costs), Number of occurrences (defects, change requests) (Page 50).",
        "Measurements Usage: Assign value to system quality attributes (e.g., maintainability via complexity metrics); identify substandard components (Page 52).",
        "Metrics Assumptions: Property measurable accurately, relationship exists between internal/external attributes, relationship formalized/validated (Page 53).",
        "Problems with Measurement in Industry: Impossible to quantify ROI, no standards, unstandardized/poorly defined processes, focus on code-based metrics in plan-driven models (irrelevant for COTS), additional overhead (Page 55).",
        "Empirical Software Engineering: Research area using experiments/real project data to validate hypotheses; difficult to relate generic research to specific projects (Page 56).",
        "Product Metrics Classes: Dynamic metrics (execution measurements, efficiency/reliability assessment); Static metrics (system representation measurements, complexity/understandability/maintainability assessment) (Page 57).",
        "Dynamic vs. Static Metrics: Dynamic (easy to measure response time, failures); Static (indirect relationship with quality attributes, try to derive relationship with complexity/maintainability) (Page 58).",
        "Static Software Product Metrics: Fan-in/Fan-out (coupling/complexity measure), Length of code (size/error-proneness), Cyclomatic complexity (control complexity/understandability), Length of identifiers, Depth of conditional nesting, Fog index (document understandability) (Page 59, 60).",
        "CK Object-oriented Metrics: WMC (Weighted methods per class - complexity/cohesion), DIT (Depth of inheritance tree - complexity of design), NOC (Number of children - breadth of hierarchy/reuse potential), CBO (Coupling between object classes - dependency), RFC (Response for a class - complexity), LCOM (Lack of cohesion in methods) (Page 61, 62).",
        "Software Component Analysis: Analyzing components using metrics; comparing values with historical data to identify anomalous components (Page 63).",
        "Process of Product Measurement: Choose measurements -> Select components -> Measure characteristics -> Identify anomalous measurements -> Analyze anomalous components (Page 64).",
        "Measurement Ambiguity: Quantitative data must be analyzed in context; easy to misinterpret data (Page 65).",
        "Measurement Surprises: Reducing faults can increase help desk calls (increased reliability widens market/changes usage patterns) (Page 66)."
      ],
      "prerequisites": [
        "ch22",
        "ch23"
      ],
      "content_reference": {
        "source_type": "slides",
        "file_name": "Chapter 24 Quality management.pdf",
        "pages": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59,
          60,
          61,
          62,
          63,
          64,
          65,
          66,
          67,
          68,
          69,
          70,
          71,
          72,
          73,
          74
        ]
      }
    },
    {
      "chapter_id": "ch25",
      "title": "Configuration Management",
      "order": 16,
      "week_label": "Week 16",
      "learning_outcomes": [
        "Define Configuration Management (CM) and its importance for managing evolving software systems.",
        "Describe the four main CM activities: Version management, System building, Change management, and Release management.",
        "Differentiate between centralized and distributed version control systems (VCS), listing the benefits of the latter (backup, offline working, project support).",
        "Explain CM terminology: Baseline, Codeline, Branching, Merging, Configuration item, Mainline, Release, Repository, Version, Workspace.",
        "Describe system building, including the role of build platforms (development, build server, target environment) and build system functionality (script generation, testing, reporting).",
        "Explain the agile building process and the concept of continuous integration.",
        "Describe methods for minimizing recompilation during system building (modification timestamps, source code checksums).",
        "Explain the change management process (CR submission, impact analysis, approval, implementation).",
        "Describe release management, including release creation, tracking, reproduction, and planning factors (timing, competition, technical quality).",
        "Discuss Software as a Service (SaaS) as an approach to reducing release management problems."
      ],
      "key_concepts": [
        "Configuration Management (CM): Policies, processes, and tools for managing changing software systems; essential to track changes, versions, and components (Page 3).",
        "CM Activities: Version management (tracking multiple versions/components), System building (assembling components/libraries into executable system), Change management (tracking, costing, approving changes), Release management (preparing/tracking external releases) (Page 4).",
        "Multi-version Systems: Large systems involve several versions at different development stages, requiring CM (Page 8).",
        "Baseline: Collection of component versions making up a controlled system; used to recreate specific versions (Page 10, 14, 15).",
        "Codeline: Sequence of versions of a software component (Page 10, 14).",
        "Branching: Creation of a new codeline from an existing version, allowing independent development (Page 10, 27).",
        "Merging: Creating new version by combining separate versions from different codelines (Page 11, 27).",
        "Version Management (VM): Process of tracking and controlling access to different component versions (Page 13).",
        "Modern Version Control Systems (VCS) Types: Centralized (single master repository, Subversion example); Distributed (multiple repository versions, Git example) (Page 17).",
        "VCS Key Features: Version/release identification, Change history recording, Support for independent development, Project support, Storage management (Page 18).",
        "Public Repository/Private Workspace: Repository holds 'master' versions (used for baselines); Developers check out to private workspace for modification, then check-in changes (Page 19).",
        "Distributed Version Control (DVC): Master repository + developer clones; developers commit changes to private repo, then 'push' to project repository (Page 22, 23).",
        "DVC Benefits: Repository backup, offline working support, default project support (developers test locally) (Page 24).",
        "Open Source DVC: Developers maintain private and public server repositories; open-source manager decides when to pull changes into definitive system (Page 25, 26).",
        "Storage Management using Deltas (Older VCS): Stores list of differences (deltas) between versions to save disk space; target version recreated by applying deltas (Page 29, 30).",
        "Storage Management in Git (Modern DVC): Does not use deltas; uses compression algorithm; stores indexed single 'packfiles'; faster retrieval (Page 31).",
        "System Building: Creating complete executable system by compiling/linking components, libraries, configuration files (Page 33).",
        "Build Platforms: Development system (tools, private workspace), Build server (builds definitive executable versions), Target environment (platform where system executes) (Page 34, 37).",
        "Build System Functionality: Build script generation, VM integration, Minimal re-compilation, Executable system creation, Test automation, Reporting, Documentation generation (Page 36).",
        "Agile Building (Continuous Integration): Frequent rebuilding and testing after new version; mainline is definitive working system; developers build/test locally before committing to mainline (Page 39, 40, 41).",
        "Continuous Integration Pros: Discover/repair interaction problems quickly, mainline is definitive system (Page 42).",
        "Continuous Integration Cons: Long build/test times for large systems/integrations, difficulty running system tests if development/target platforms differ (Page 42).",
        "Minimizing Recompilation: Tools check if compiled component is available before recompilation (Page 44).",
        "File Identification: Modification timestamps (time/date modified; checks if source code is newer than object code); Source code checksums (unique number calculated from data; changed when source code edited) (Page 45).",
        "Timestamps vs Checksums: Checksums allow parallel compilation of different versions; timestamps link source/object by name (Page 46, 47).",
        "Change Management: Managing system evolution (bugs, adaptations, requirements change); priority given to urgent/cost-effective changes; process involves analyzing costs/benefits and tracking component changes (Page 49, 50).",
        "Change Analysis Factors: Consequences/benefits of change, number of users affected, costs, product release cycle (Page 53).",
        "Change Management Process: Problem analysis/change specification -> Change analysis/costing (traceability) -> Change implementation (modifying requirements document/design/implementation) (Page 83, 84 in Ch4 but contextually linked to Ch25).",
        "Agile Change Management: Customers directly involved; programmers decide on software improvements; Refactoring (continuous improvement, not overhead) (Page 55).",
        "Release Management: Process of testing, preparing, and distributing system versions to customers (Page 57).",
        "Types of Release: Major (significant new functionality), Minor (repair bugs/customer problems), Custom (multiple releases for different customers running concurrently) (Page 57).",
        "Release Components: Executable code, configuration files, data files, installation program, documentation, packaging/publicity (Page 58).",
        "Factors Influencing Release Planning: Competition (new features needed), Marketing requirements (commitment to dates), Platform changes (new OS release), Technical quality of the system (fault repair/patches) (Page 59).",
        "Release Creation: Identify code/data files, write configuration descriptions/update instructions/installation scripts, create web pages, prepare master executable image (Page 60).",
        "Release Tracking/Reproduction: Documenting system release for future re-creation; important for customized, long-lifetime embedded systems (Page 61, 62).",
        "Release Timing: Trade-off between frequent releases (customer resistance to upgrades/cost) and infrequent releases (market share loss) (Page 63).",
        "Software as a Service (SaaS) and RM: Reduces RM problems; simplifies installation; developer responsible for replacing existing release with new release for all customers simultaneously (Page 64)."
      ],
      "prerequisites": [
        "ch4",
        "ch22"
      ],
      "content_reference": {
        "source_type": "slides",
        "file_name": "Chapter 25 Configuration Management.pdf",
        "pages": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59,
          60,
          61,
          62,
          63,
          64,
          65,
          66
        ]
      }
    }
  ],
  "assessments": []
}